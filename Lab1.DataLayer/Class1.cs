// https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/sql-server-schema-collections?redirectedfrom=MSDN
using System.Collections.ObjectModel;
using System.Data;
using Microsoft.Data.SqlClient;

namespace Lab1.DataLayer;

public sealed class TableModel
{
    public required FullTableName Name;
    public required List<ColumnModel> Columns { get; init; }
}

public struct ColumnModel
{
    public string Name { get; set; }
    public bool IsOptional { get; set; }
    public bool IsAutoGenerated { get; set; }
}

public readonly record struct FullTableName
{
    public required string Catalog { get; init; }
    public required string Schema { get; init; }
    public required string Name { get; init; }
}

public struct TableInfoRow
{
    public string Catalog;
    public string Schema;
    public string Name;
    public string Type;

    public static TableInfoRow Parse(DataRow row)
    {
        TableInfoRow result;
        result.Catalog = (string) row[0];
        result.Schema = (string) row[1];
        result.Name = (string) row[2];
        result.Type = (string) row[3];
        return result;
    }

    public FullTableName GetFullName()
    {
        return new()
        {
            Catalog = Catalog,
            Name = Name,
            Schema = Schema,
        };
    }
}

public struct ColumnInfoRow
{
    public ColumnInfoRow(DataRow row)
    {
        Row = row;
    }

    public DataRow Row { get; }

    public const int TableCatalogIndex = 0;
    public string TableCatalog => (string) Row[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public string TableSchema => (string) Row[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public string TableName => (string) Row[TableNameIndex];

    public FullTableName GetFullTableName()
    {
        return new()
        {
            Catalog = TableCatalog,
            Name = TableName,
            Schema = TableSchema,
        };
    }

    public const int ColumnNameIndex = 3;
    public string ColumnName => (string) Row[ColumnNameIndex];

    public const int OrdinalPositionIndex = 4;
    public int OrdinalPosition => (int) Row[OrdinalPositionIndex];

    public const int DefaultIndex = 5;
    public string? Default => Row[DefaultIndex] as string;

    public const int IsNullableIndex = 6;
    public bool IsNullable => Row[IsNullableIndex] is "YES";

    public const int DataTypeIndex = 7;
    public string DataType => (string) Row[DataTypeIndex];
}

public readonly struct TableConstraints
{
    public readonly string?[] Values;
    public const int Count = 4;
    public static TableConstraints Create() => new(new string?[Count]);
    private TableConstraints(string?[] values) => Values = values;

    public const int CatalogIndex = 0;
    public ref string? Catalog => ref Values[CatalogIndex];

    public const int SchemaIndex = 1;
    public ref string? Schema => ref Values[SchemaIndex];

    public const int NameIndex = 2;
    public ref string? Name => ref Values[NameIndex];

    public const int TypeIndex = 3;

    public TableType? Type
    {
        get
        {
            switch (Values[TypeIndex])
            {
                case "VIEW":
                    return TableType.View;
                case "BASE TABLE":
                    return TableType.BaseTable;
                default:
                    return null;
            }
        }
        set
        {
            Values[TypeIndex] = value switch
            {
                TableType.View => "VIEW",
                TableType.BaseTable => "BASE TABLE",
                null => null,
                _ => throw new ArgumentException(nameof(value)),
            };
        }
    }

    public static implicit operator string?[](TableConstraints tableConstraints) => tableConstraints.Values;
}

public readonly struct ColumnConstraints
{
    public readonly string?[] Values;
    public const int Count = 3;
    public static ColumnConstraints Create() => new(new string?[Count]);
    private ColumnConstraints(string?[] values) => Values = values;

    public const int TableCatalogIndex = 0;
    public ref string? TableCatalog => ref Values[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public ref string? TableSchema => ref Values[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public ref string? TableName => ref Values[TableNameIndex];
}

public enum TableType
{
    View,
    BaseTable,
}

public static class DatabaseSchemaHelper
{
    public static async Task<TableModel[]> GetTables(
        SqlConnection connection,
        CancellationToken cancellationToken = default)
    {
        DataTable tablesTable;
        {
            var c = TableConstraints.Create();
            c.Type = TableType.BaseTable;
            tablesTable = await connection.GetSchemaAsync("Tables", c, cancellationToken);
        }

        Dictionary<FullTableName, int> tableNameToIndex;
        {
            var rows = tablesTable.Rows;
            tableNameToIndex = new(rows.Count);
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var parsedRow = TableInfoRow.Parse(row);
                tableNameToIndex.Add(parsedRow.GetFullName(), i);
            }
        }

        var tableModels = new TableModel[tableNameToIndex.Count];
        foreach (var (tableName, index) in tableNameToIndex)
        {
            tableModels[index] = new TableModel
            {
                Columns = new(),
                Name = tableName,
            };
        }

        DataTable columnsTable = await connection.GetSchemaAsync("Columns", cancellationToken);
        {
            var rows = columnsTable.Rows;
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var wrapped = new ColumnInfoRow(row);
                var fullTableName = wrapped.GetFullTableName();
                if (!tableNameToIndex.TryGetValue(fullTableName, out int tableIndex))
                    continue;

                var tableModel = tableModels[tableIndex];
                var columnModel = new ColumnModel
                {
                    Name = wrapped.ColumnName,
                    IsOptional = wrapped.IsNullable,
                    IsAutoGenerated = wrapped.Default is not null,
                };
                tableModel.Columns.Add(columnModel);
            }
        }

        return tableModels;
    }
}