// https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/sql-server-schema-collections?redirectedfrom=MSDN
using System.Data;
using System.Runtime.InteropServices;
using Microsoft.Data.SqlClient;

namespace Lab1.DataLayer;

public sealed class TableModel
{
    public required FullTableName Name;
    public required List<ColumnModel> Columns { get; init; }
}

public struct ColumnModel
{
    public string Name { get; set; }
    public bool IsOptional { get; set; }
    public bool HasDefault { get; set; }
    public bool IsAutoGenerated { get; set; }
    public bool IsId => IsAutoGenerated;
}

public readonly record struct FullTableName
{
    public required string Schema { get; init; }
    public required string Name { get; init; }
}

public struct TableInfoRow
{
    public string Schema;
    public string Name;

    public static TableInfoRow Parse(DataRow row)
    {
        TableInfoRow result;
        result.Schema = (string) row[1];
        result.Name = (string) row[2];
        return result;
    }

    public FullTableName GetFullName()
    {
        return new()
        {
            Name = Name,
            Schema = Schema,
        };
    }
}

public struct ColumnInfoRow
{
    public ColumnInfoRow(DataRow row)
    {
        Row = row;
    }

    public DataRow Row { get; }

    public const int TableCatalogIndex = 0;
    public string TableCatalog => (string) Row[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public string TableSchema => (string) Row[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public string TableName => (string) Row[TableNameIndex];

    public FullTableName GetFullTableName()
    {
        return new()
        {
            Name = TableName,
            Schema = TableSchema,
        };
    }

    public const int ColumnNameIndex = 3;
    public string ColumnName => (string) Row[ColumnNameIndex];

    public const int OrdinalPositionIndex = 4;
    public int OrdinalPosition => (int) Row[OrdinalPositionIndex];

    public const int DefaultIndex = 5;
    public string? Default => Row[DefaultIndex] as string;

    public const int IsNullableIndex = 6;
    public bool IsNullable => Row[IsNullableIndex] is "YES";

    public const int DataTypeIndex = 7;
    public string DataType => (string) Row[DataTypeIndex];
}

public readonly struct TableConstraints
{
    public readonly string?[] Values;
    public const int Count = 4;
    public static TableConstraints Create() => new(new string?[Count]);
    private TableConstraints(string?[] values) => Values = values;

    public const int CatalogIndex = 0;
    public ref string? Catalog => ref Values[CatalogIndex];

    public const int SchemaIndex = 1;
    public ref string? Schema => ref Values[SchemaIndex];

    public const int NameIndex = 2;
    public ref string? Name => ref Values[NameIndex];

    public const int TypeIndex = 3;

    public TableType? Type
    {
        get
        {
            switch (Values[TypeIndex])
            {
                case "VIEW":
                    return TableType.View;
                case "BASE TABLE":
                    return TableType.BaseTable;
                default:
                    return null;
            }
        }
        set
        {
            Values[TypeIndex] = value switch
            {
                TableType.View => "VIEW",
                TableType.BaseTable => "BASE TABLE",
                null => null,
                _ => throw new ArgumentException(nameof(value)),
            };
        }
    }

    public static implicit operator string?[](TableConstraints tableConstraints) => tableConstraints.Values;
}

public readonly struct ColumnConstraints
{
    public readonly string?[] Values;
    public const int Count = 3;
    public static ColumnConstraints Create() => new(new string?[Count]);
    private ColumnConstraints(string?[] values) => Values = values;

    public const int TableCatalogIndex = 0;
    public ref string? TableCatalog => ref Values[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public ref string? TableSchema => ref Values[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public ref string? TableName => ref Values[TableNameIndex];
}

public enum TableType
{
    View,
    BaseTable,
}

public static class DatabaseSchemaHelper
{
    public static async Task<TableModel[]> GetTables(
        SqlConnection connection,
        CancellationToken cancellationToken = default)
    {
        DataTable tablesTable;
        {
            var c = TableConstraints.Create();
            c.Type = TableType.BaseTable;
            tablesTable = await connection.GetSchemaAsync("Tables", c, cancellationToken);
        }

        Dictionary<FullTableName, int> tableNameToIndex;
        {
            var rows = tablesTable.Rows;
            tableNameToIndex = new(rows.Count);
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var parsedRow = TableInfoRow.Parse(row);
                tableNameToIndex.Add(parsedRow.GetFullName(), i);
            }
        }

        var tableModels = new TableModel[tableNameToIndex.Count];
        foreach (var (tableName, index) in tableNameToIndex)
        {
            tableModels[index] = new TableModel
            {
                Columns = new(),
                Name = tableName,
            };
        }

        DataTable columnsTable = await connection.GetSchemaAsync("Columns", cancellationToken);
        {
            var rows = columnsTable.Rows;
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var wrapped = new ColumnInfoRow(row);
                var fullTableName = wrapped.GetFullTableName();
                if (!tableNameToIndex.TryGetValue(fullTableName, out int tableIndex))
                    continue;

                var tableModel = tableModels[tableIndex];
                var columnModel = new ColumnModel
                {
                    Name = wrapped.ColumnName,
                    IsOptional = wrapped.IsNullable,
                    HasDefault = wrapped.Default is not null,
                };
                tableModel.Columns.Add(columnModel);
            }
        }

        // To find out if it's autoincremented, we need to use provider specific queries.
        SupportedProvider providerType;
        {
            // TODO: Get this from the connection somehow??
            providerType = SupportedProvider.SqlServer;
        }

        switch (providerType)
        {
            case SupportedProvider.SqlServer:
            {
                const string query = $"""
                SELECT 
                    schemas.name as TABLE_SCHEMA,
                    tables.name as TABLE_NAME,
                    columns.name as COLUMN_NAME

                FROM sys.columns as columns
                INNER JOIN sys.tables as tables
                    ON tables.object_id = columns.object_id
                INNER JOIN sys.schemas as schemas
                    ON tables.schema_id = schemas.schema_id

                WHERE columns.is_identity = 1
                """;
                var command = connection.CreateCommand();
                command.CommandText = query;
                command.CommandType = CommandType.Text;
                var reader = await command.ExecuteReaderAsync(cancellationToken);
                while (await reader.ReadAsync(cancellationToken))
                {
                    var tableSchema = reader.GetString(0);
                    var tableName = reader.GetString(1);
                    var columnName = reader.GetString(2);
                    var tableFullName = new FullTableName
                    {
                        Name = tableName,
                        Schema = tableSchema,
                    };
                    if (!tableNameToIndex.TryGetValue(tableFullName, out int tableModelIndex))
                        continue;

                    var tableModel = tableModels[tableModelIndex];
                    // find the column
                    var index = tableModel.Columns.FindIndex(c => c.Name == columnName);

                    void Set()
                    {
                        ref var columnModel = ref CollectionsMarshal.AsSpan(tableModel.Columns)[index];
                        columnModel.IsAutoGenerated = true;
                    }
                    Set();
                }

                break;
            }

            // ReSharper disable once UnreachableSwitchCaseDueToIntegerAnalysis
            default:
            {
                throw new NotImplementedException();
            }
        }

        foreach (var tableModel in tableModels)
        {
            tableModel.Columns.Sort(
                (c1, c2) => string.Compare(c1.Name, c2.Name, StringComparison.Ordinal));
        }
        Array.Sort(tableModels, (t1, t2) =>
        {
            if (string.Compare(t1.Name.Schema, t2.Name.Schema, StringComparison.Ordinal) is { } t
                && t != 0)
            {
                return t;
            }
            return string.Compare(t1.Name.Name, t2.Name.Name, StringComparison.Ordinal);
        });


        return tableModels;
    }
}

public enum SupportedProvider
{
    SqlServer,
}