// https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/sql-server-schema-collections?redirectedfrom=MSDN
using System.Data;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Data.SqlClient;

namespace Lab1.DataLayer;

public sealed class TableModel
{
    public required FullTableName Name;
    public required List<ColumnSchema> Columns { get; init; }

    public FullyQualifiedName FullyQualifiedName => new(Name.Schema, Name.Name);
    public IEnumerable<ColumnSchema> IdColumns => Columns.Where(c => c.IsId);
}

public sealed class ColumnSchema
{
    public required string Name { get; set; }
    public required Type Type { get; set; }
    public required string DatabaseType { get; set; }
    public required bool IsOptional { get; set; }
    public required bool HasDefault { get; set; }
    public required bool IsAutoGenerated { get; set; }
    public required bool IsId { get; set; }
}

public readonly record struct FullTableName
{
    public required string Schema { get; init; }
    public required string Name { get; init; }
}

public struct TableInfoRow
{
    public string Schema;
    public string Name;

    public static TableInfoRow Parse(DataRow row)
    {
        TableInfoRow result;
        result.Schema = (string) row[1];
        result.Name = (string) row[2];
        return result;
    }

    public FullTableName GetFullName()
    {
        return new()
        {
            Name = Name,
            Schema = Schema,
        };
    }
}

public struct ColumnInfoRow
{
    public ColumnInfoRow(DataRow row)
    {
        Row = row;
    }

    public DataRow Row { get; }

    public const int TableCatalogIndex = 0;
    public string TableCatalog => (string) Row[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public string TableSchema => (string) Row[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public string TableName => (string) Row[TableNameIndex];

    public FullTableName GetFullTableName()
    {
        return new()
        {
            Name = TableName,
            Schema = TableSchema,
        };
    }

    public const int ColumnNameIndex = 3;
    public string ColumnName => (string) Row[ColumnNameIndex];

    public const int OrdinalPositionIndex = 4;
    public int OrdinalPosition => (int) Row[OrdinalPositionIndex];

    public const int DefaultIndex = 5;
    public string? Default => Row[DefaultIndex] as string;

    public const int IsNullableIndex = 6;
    public bool IsNullable => Row[IsNullableIndex] is "YES";

    public const int DataTypeIndex = 7;
    public string DataType => (string) Row[DataTypeIndex];


    private int? GetLengthVariable(int index)
    {
        var t = Row[index];
        if (t is DBNull)
            return null;
        if (t is int i)
            return i;
        if (t is short l)
            return (short) l;
        return null;
    }

    public const int CharacterMaximumLengthIndex = 8;
    public int? CharacterMaximumLength => GetLengthVariable(CharacterMaximumLengthIndex);

    public const int CharacterOctetLengthIndex = 9;
    public int? CharacterOctetLength => GetLengthVariable(CharacterOctetLengthIndex);

    public const int NumericPrecisionIndex = 10;
    public int? NumericPrecision => GetLengthVariable(NumericPrecisionIndex);

    public const int NumericPrecisionRadixIndex = 11;
    public int? NumericPrecisionRadix => GetLengthVariable(NumericPrecisionRadixIndex);

    public const int NumericScaleIndex = 12;
    public int? NumericScale => GetLengthVariable(NumericScaleIndex);

    public const int DatetimePrecisionIndex = 13;
    public int? DatetimePrecision => GetLengthVariable(DatetimePrecisionIndex);

    public string FullDatabaseType
    {
        get
        {
            if (CharacterMaximumLength is { } length)
            {
                return $"{DataType}({length})";
            }

            if (NumericPrecision is { } precision)
            {
                if (NumericScale is { } scale)
                {
                    return $"{DataType}({precision}, {scale})";
                }
                else
                {
                    return $"{DataType}({precision})";
                }
            }

            if (DatetimePrecision is { } datetimePrecision)
            {
                return $"{DataType}({datetimePrecision})";
            }

            return DataType;
        }
    }
}

public readonly struct TableConstraints
{
    public readonly string?[] Values;
    public const int Count = 4;
    public static TableConstraints Create() => new(new string?[Count]);
    private TableConstraints(string?[] values) => Values = values;

    public const int CatalogIndex = 0;
    public ref string? Catalog => ref Values[CatalogIndex];

    public const int SchemaIndex = 1;
    public ref string? Schema => ref Values[SchemaIndex];

    public const int NameIndex = 2;
    public ref string? Name => ref Values[NameIndex];

    public const int TypeIndex = 3;

    public TableType? Type
    {
        get
        {
            switch (Values[TypeIndex])
            {
                case "VIEW":
                    return TableType.View;
                case "BASE TABLE":
                    return TableType.BaseTable;
                default:
                    return null;
            }
        }
        set
        {
            Values[TypeIndex] = value switch
            {
                TableType.View => "VIEW",
                TableType.BaseTable => "BASE TABLE",
                null => null,
                _ => throw new ArgumentException(nameof(value)),
            };
        }
    }

    public static implicit operator string?[](TableConstraints tableConstraints) => tableConstraints.Values;
}

public readonly struct ColumnConstraints
{
    public readonly string?[] Values;
    public const int Count = 3;
    public static ColumnConstraints Create() => new(new string?[Count]);
    private ColumnConstraints(string?[] values) => Values = values;

    public const int TableCatalogIndex = 0;
    public ref string? TableCatalog => ref Values[TableCatalogIndex];

    public const int TableSchemaIndex = 1;
    public ref string? TableSchema => ref Values[TableSchemaIndex];

    public const int TableNameIndex = 2;
    public ref string? TableName => ref Values[TableNameIndex];
}

public enum TableType
{
    View,
    BaseTable,
}

public static class DatabaseSchemaHelper
{
    public static async Task<TableModel[]> GetTables(
        SqlConnection connection,
        CancellationToken cancellationToken = default)
    {
        DataTable tablesTable;
        {
            var c = TableConstraints.Create();
            c.Type = TableType.BaseTable;
            tablesTable = await connection.GetSchemaAsync("Tables", c, cancellationToken);
        }

        Dictionary<FullTableName, int> tableNameToIndex;
        {
            var rows = tablesTable.Rows;
            tableNameToIndex = new(rows.Count);
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var parsedRow = TableInfoRow.Parse(row);
                tableNameToIndex.Add(parsedRow.GetFullName(), i);
            }
        }

        var tableModels = new TableModel[tableNameToIndex.Count];
        foreach (var (tableName, index) in tableNameToIndex)
        {
            tableModels[index] = new TableModel
            {
                Columns = new(),
                Name = tableName,
            };
        }

        DataTable columnsTable = await connection.GetSchemaAsync("Columns", cancellationToken);
        {
            var rows = columnsTable.Rows;
            for (int i = 0; i < rows.Count; i++)
            {
                var row = rows[i];
                var wrapped = new ColumnInfoRow(row);
                var fullTableName = wrapped.GetFullTableName();
                if (!tableNameToIndex.TryGetValue(fullTableName, out int tableIndex))
                    continue;

                var tableModel = tableModels[tableIndex];
                var columnModel = new ColumnSchema
                {
                    Type = wrapped.DataType switch
                    {
                        "int" => typeof(int),
                        "nvarchar" or "ntext" or "nchar" => typeof(string),
                        "bit" => typeof(bool),
                        "datetime" => typeof(DateTime),
                        "uniqueidentifier" => typeof(Guid),
                        "money" => typeof(decimal),
                        "smallint" => typeof(short),
                        "real" => typeof(float),
                        "image" or "varbinary" => typeof(byte[]),
                        _ => throw new NotSupportedException("Unsupported type: " + wrapped.DataType),
                    },
                    DatabaseType = wrapped.FullDatabaseType,
                    Name = wrapped.ColumnName,
                    IsOptional = wrapped.IsNullable,
                    HasDefault = wrapped.Default is not null,

                    // Set after.
                    IsAutoGenerated = false,
                    IsId = false,
                };
                tableModel.Columns.Add(columnModel);
            }
        }

        // To find out if it's autoincremented, we need to use provider specific queries.
        SupportedProvider providerType;
        {
            // TODO: Get this from the connection somehow??
            providerType = SupportedProvider.SqlServer;
        }

        switch (providerType)
        {
            case SupportedProvider.SqlServer:
            {
                const string query = $"""
                SELECT 
                    schemas.name as TABLE_SCHEMA,
                    tables.name as TABLE_NAME,
                    columns.name as COLUMN_NAME,
                    columns.is_identity as IS_IDENTITY,
                    ISNULL(indices.is_primary_key, 0) as IS_PRIMARY_KEY

                FROM sys.columns as columns
                INNER JOIN sys.tables as tables
                    ON tables.object_id = columns.object_id
                INNER JOIN sys.schemas as schemas
                    ON tables.schema_id = schemas.schema_id
                    
                LEFT JOIN sys.index_columns AS indexColumns 
                    ON indexColumns.object_id = columns.object_id
                        AND indexColumns.column_id = columns.column_id
                LEFT JOIN sys.indexes AS indices
                    ON indices.object_id = indexColumns.object_id
                        AND indices.index_id = indexColumns.index_id

                WHERE columns.is_identity = 1
                    OR indices.is_primary_key is null
                    OR indices.is_primary_key = 1;
                
                SELECT 
                    OBJECT_NAME(indexColumns.OBJECT_ID) AS TableName,
                    COL_NAME(indexColumns.OBJECT_ID, indexColumns.column_id) AS ColumnName
                       
                FROM sys.indexes AS indices 
                INNER JOIN sys.index_columns AS indexColumns 
                    ON indices.OBJECT_ID = indexColumns.OBJECT_ID
                        AND indices.index_id = indexColumns.index_id
                WHERE indices.is_primary_key = 1;
                """;
                var command = connection.CreateCommand();
                command.CommandText = query;
                command.CommandType = CommandType.Text;
                await using var reader = await command.ExecuteReaderAsync(cancellationToken);

                while (await reader.ReadAsync(cancellationToken))
                {
                    var tableSchema = reader.GetString(0);
                    var tableName = reader.GetString(1);
                    var columnName = reader.GetString(2);
                    var isIdentity = reader.GetBoolean(3);
                    var isPrimaryKey = reader.GetBoolean(4);
                    var tableFullName = new FullTableName
                    {
                        Name = tableName,
                        Schema = tableSchema,
                    };
                    if (!tableNameToIndex.TryGetValue(tableFullName, out int tableModelIndex))
                        continue;

                    var tableModel = tableModels[tableModelIndex];
                    var index = tableModel.Columns.FindIndex(c => c.Name == columnName);

                    void Set()
                    {
                        ref var columnModel = ref CollectionsMarshal.AsSpan(tableModel.Columns)[index];
                        columnModel.IsAutoGenerated = isIdentity;
                        columnModel.IsId = isPrimaryKey;
                    }
                    Set();
                }

                break;
            }

            // ReSharper disable once UnreachableSwitchCaseDueToIntegerAnalysis
            default:
            {
                throw new NotImplementedException();
            }
        }

        foreach (var tableModel in tableModels)
        {
            tableModel.Columns.Sort(
                (c1, c2) => string.Compare(c1.Name, c2.Name, StringComparison.Ordinal));
        }
        Array.Sort(tableModels, (t1, t2) =>
        {
            if (string.Compare(t1.Name.Schema, t2.Name.Schema, StringComparison.Ordinal) is { } t
                && t != 0)
            {
                return t;
            }
            return string.Compare(t1.Name.Name, t2.Name.Name, StringComparison.Ordinal);
        });


        return tableModels;
    }
}

public enum SupportedProvider
{
    SqlServer,
}