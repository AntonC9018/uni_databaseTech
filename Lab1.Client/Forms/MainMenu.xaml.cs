using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Lab1.DataLayer;
using Microsoft.Data.SqlClient;
using DataSet = System.Data.DataSet;

namespace Laborator1;

public sealed partial class MainMenuModel : ObservableObject
{
    public TableModel[]? TableModels;
    public DataSet? DataSet;
    public readonly List<SqlDataAdapter> Adapters = new();

    [ObservableProperty]
    private int? _currentTableSchemaIndex = null;

    public List<string> ColumnValues = new();

    public TableModel? CurrentTableModel
    {
        get
        {
            if (TableModels is null)
                return null;
            if (CurrentTableSchemaIndex is { } index)
                return TableModels[index];
            return null;
        }
    }

    public DataTable? CurrentDataTable
    {
        get
        {
            if (DataSet is null)
                return null;
            if (CurrentTableSchemaIndex is { } index)
                return DataSet.Tables[index];
            return null;
        }
    }

    public SqlDataAdapter? CurrentDataAdapter
    {
        get
        {
            if (CurrentTableSchemaIndex is { } index)
                return Adapters[index];
            return null;
        }
    }

    public IList<ColumnSchema> ColumnSchemas
    {
        get
        {
            var table = CurrentTableModel;
            if (table is null)
                return Array.Empty<ColumnSchema>();
            return table.Columns;
        }
    }

    public void TriggerAllValuesChanged()
    {
        OnPropertyChanged(nameof(ColumnValues));
    }
}

public sealed class TableSchemaModel
{
    public TableSchemaModel(TableModel model) => Model = model;

    public TableModel Model { get; }

    public string Name => Model.Name.Name;
    public string Schema => Model.Name.Schema;
    public FullyQualifiedName FullyQualifiedName => new(Schema, Name);
    public override string ToString() => FullyQualifiedName.ToString();
}

public sealed partial class ColumnViewModel : ObservableObject
{
    public ColumnViewModel(MainMenuModel model, int index)
    {
        _model = model;
        _index = index;
    }

    private readonly MainMenuModel _model;
    private readonly int _index;

    private ColumnSchema Schema => _model.ColumnSchemas[_index];
    public string Name => Schema.Name;

    public string Value
    {
        get => _model.ColumnValues[_index];
        set => _model.ColumnValues[_index] = value;
    }

    public bool IsReadOnly => Schema.IsAutoGenerated;
    public bool IsEditable => !Schema.IsAutoGenerated;

    internal void OnTableChanged()
    {
        OnPropertyChanged(nameof(IsReadOnly));
        OnPropertyChanged(nameof(Name));
    }

    internal void OnRowChanged()
    {
        OnPropertyChanged(nameof(Value));
    }
}

public sealed partial class MainMenuViewModel : ObservableObject
{
    public MainMenuViewModel(
        SqlConnection connection,
        CancellationToken applicationCancellationToken,
        MainMenuModel model)
    {
        _connection = connection;
        _applicationCancellationToken = applicationCancellationToken;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(applicationCancellationToken);
        _loadingCancellationToken = _cts.Token;
        _model = model;

        _model.PropertyChanged += (_, args) =>
        {
            switch (args.PropertyName)
            {
                case nameof(MainMenuModel.ColumnValues):
                {
                    foreach (var column in _columns)
                        column.OnRowChanged();
                    break;
                }
                case nameof(MainMenuModel.CurrentTableSchemaIndex):
                {
                    CurrentTableSchemaIndex = _model.CurrentTableSchemaIndex;
                    break;
                }
            }
        };

        LoadTablesFireAndForget();
    }

    private readonly MainMenuModel _model;
    private readonly ObservableCollection<ColumnViewModel> _columns = new();
    private readonly SqlConnection _connection;
    private TableSchemaModel[] _tables = Array.Empty<TableSchemaModel>();

    [ObservableProperty]
    private int? _currentTableSchemaIndex;

    partial void OnCurrentTableSchemaIndexChanging(int? value)
    {
        if (value is { } v)
        {
            SelectTable(v);
            MoveToRowFireAndForget(0);
        }
        IsTableSelected = value is not null;
    }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsTableSelected))]
    [NotifyPropertyChangedFor(nameof(IsRowSelected))]
    [NotifyPropertyChangedFor(nameof(ViewCurrentRowIndex))]
    private int? _currentTableRowIndex = null;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    private bool _isFirstRow = true;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    private bool _isLastRow = true;

    public IEnumerable<TableSchemaModel> TableSchemas => _tables;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    private bool _isLoading;

    private readonly CancellationToken _applicationCancellationToken;
    private CancellationToken _loadingCancellationToken;
    private CancellationTokenSource _cts;
    private readonly SemaphoreSlim _loadingOperationLock = new(1, 1);

    [ObservableProperty]
    private bool _isTableSelected;

    public bool CanMovePreviousRow => !IsFirstRow && !IsLoading;
    public bool CanMoveNextRow => !IsLastRow && !IsLoading;
    public bool IsRowSelected => CurrentTableRowIndex is not null;

    public int ViewCurrentRowIndex
    {
        get => CurrentTableRowIndex ?? 0;
        set
        {
            if (CurrentTableRowIndex == value)
                return;
            MoveToRowFireAndForget(value);
        }
    }

    public ObservableCollection<ColumnViewModel> Columns => _columns;

    private int GetOffsetCurrentIndexWithFallback(int offset)
    {
        int? maybeCurrentRowIndex = CurrentTableRowIndex;
        int rowIndex;
        if (maybeCurrentRowIndex is null)
            rowIndex = 0;
        else
            rowIndex = maybeCurrentRowIndex.Value + offset;
        return rowIndex;
    }

    private void LoadTablesFireAndForget()
    {
        DoOperationFireAndForget(async () =>
        {
            await _connection.OpenAsync(_loadingCancellationToken);
            if (_connection.State != ConnectionState.Open)
                return "Failed to open connection.";

            var tables = await DatabaseSchemaHelper.GetTables(_connection, _loadingCancellationToken);

            StringBuilder errorBuilder = new();
            {
                foreach (var t in tables)
                {
                    if (!t.IdColumns.Any())
                    {
                        errorBuilder.AppendLine($"Table {t.Name} doesn't have an id column.");
                    }
                }

                if (errorBuilder.Length > 0)
                {
                    return errorBuilder.ToString();
                }
            }
            {
                // We filter each column so that it doesn't know about byte[] types,
                // which cannot be converted from string.
                foreach (var table in tables)
                {
                    table.Columns.RemoveAll(c =>
                    {
                        bool isRepresentableAsString = c.IsTypeRepresentableAsString();
                        if (!c.IsOptional && !isRepresentableAsString)
                        {
                            errorBuilder.AppendLine($"Column {c.Name} of table {table.Name} is not optional and cannot be represented as a string.");
                        }
                        return !isRepresentableAsString;
                    });
                }

                if (errorBuilder.Length > 0)
                {
                    return errorBuilder.ToString();
                }
            }

            _tables = tables.Select(t => new TableSchemaModel(t)).ToArray();

            var set = new DataSet();
            var sb = new StringBuilder();
            for (int i = 0; i < _tables.Length; i++)
            {
                var table = _tables[i].Model;
                var dataTable = set.Tables.Add(table.Name.Name);
                foreach (var column in _tables[i].Model.Columns)
                    dataTable.Columns.Add(column.Name, column.Type);

                var adapter = new SqlDataAdapter($"SELECT * FROM {table.FullyQualifiedName}", _connection);
                adapter.UpdateCommand = QueryBuilderHelper.UpdateRow.CreateCommand(sb, table);
                adapter.InsertCommand = QueryBuilderHelper.InsertRow.CreateCommand(sb, table);
                adapter.DeleteCommand = QueryBuilderHelper.DeleteRow.CreateCommand(sb, table);
                adapter.Fill(dataTable);
            }
            _model.DataSet = set;

            _model.TableModels = tables;
            if (_tables.Length > 0)
                SelectTable(0);
            OnPropertyChanged(nameof(TableSchemas));

            await MoveToRow(0);

            return null;
        });
    }

    [RelayCommand]
    public void MovePreviousRow()
    {
        if (!CanMovePreviousRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
        MoveToRowFireAndForget(rowIndex);
    }

    [RelayCommand]
    public void MoveNextRow()
    {
        if (!CanMoveNextRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(1);
        MoveToRowFireAndForget(rowIndex);
    }

    private record struct ErrorMessage(string? Value)
    {
        public static implicit operator ErrorMessage(string? value)
        {
            if (value is not null)
                throw new InvalidOperationException(value);
            return new(value);
        }
    }

    private async void DoOperationFireAndForget(Func<Task<ErrorMessage>> func)
    {
        await DoOperationFireAndForget1(func);
    }

    private async Task DoOperationFireAndForget1(Func<Task<ErrorMessage>> func)
    {
        if (IsLoading)
            return;

        try
        {
            await _loadingOperationLock.WaitAsync(_loadingCancellationToken);
        }
        catch (Exception)
        {
            return;
        }

        try
        {
            if (IsLoading)
                return;

            IsLoading = true;

            try
            {
                var errorMessage = await func();
                if (errorMessage.Value is not null)
                {
                    MessageBox.Show(errorMessage.Value);
                }
            }
            catch (Exception e)
            {
                StringBuilder sb = new();

                Append(e);
                // ReSharper disable once VariableHidesOuterVariable
                void Append(Exception e)
                {
                    sb.AppendLine(e.Message);
                    sb.AppendLine(e.StackTrace);
                    if (e.InnerException is { } inner)
                    {
                        Append(inner);
                    }
                    if (e is AggregateException aggregateException)
                    {
                        foreach (var innerException in aggregateException.InnerExceptions)
                        {
                            Append(innerException);
                        }
                    }
                }

                // Aggregate exception
                MessageBox.Show(sb.ToString(), "Error");
            }

            IsLoading = false;
        }
        finally
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(_applicationCancellationToken);
            _loadingCancellationToken = _cts.Token;
            _loadingOperationLock.Release();
        }
    }

    private void MoveToRowFireAndForget(int rowIndex)
    {
        DoOperationFireAndForget(async () =>
        {
            bool rowFound = await MoveToRow(rowIndex);
            if (!rowFound)
                return $"Failed to move to row {rowIndex}.";
            return null;
        });
    }

    [RelayCommand]
    public void DeleteCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoDeleteCurrent();
            return null;
        });
    }

    [RelayCommand]
    public void InsertCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoInsertCurrent();
            return null;
        });
    }

    [RelayCommand]
    public void SaveCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoSaveCurrent();
            return null;
        });
    }

    private TableSchemaModel GetCurrentTable()
    {
        int? maybeSchemaIndex = _model.CurrentTableSchemaIndex;
        Debug.Assert(maybeSchemaIndex is not null);
        int schemaIndex = maybeSchemaIndex.Value;

        var table = _tables[schemaIndex];
        return table;
    }

    private Task<bool> MoveToRow(int rowIndex)
    {
        var dataTable = _model.CurrentDataTable;
        Debug.Assert(dataTable is not null);
        int rowCount = dataTable.Rows.Count;

        IsLastRow = rowIndex == rowCount - 1;
        IsFirstRow = rowIndex == 0;

        if (rowIndex >= 0 && rowIndex < rowCount)
        {
            var row = dataTable.Rows[rowIndex];
            var columnValues = _model.ColumnValues;

            for (int i = 0; i < columnValues.Count; i++)
            {
                var value = row[i];
                _model.ColumnValues[i] = value.ToString() ?? "";
            }

            CurrentTableRowIndex = rowIndex;
        }
        else
        {
            CurrentTableRowIndex = null;
        }
        _model.TriggerAllValuesChanged();
        return Task.FromResult(true);
    }

    private async Task DoDeleteCurrent()
    {
        var dataTable = _model.CurrentDataTable;
        Debug.Assert(dataTable is not null);

        Debug.Assert(CurrentTableRowIndex is not null);
        int currentIndex = CurrentTableRowIndex!.Value;

        var row = dataTable.Rows[currentIndex];
        row.Delete();

        if (IsLastRow && IsFirstRow)
        {
            CurrentTableRowIndex = null;
        }
        else
        {
            int direction = IsLoading ? -1 : 1;
            int rowIndex = GetOffsetCurrentIndexWithFallback(direction);
            await MoveToRow(rowIndex);
        }
    }

    private async Task DoInsertCurrent()
    {
        var dataTable = _model.CurrentDataTable;
        Debug.Assert(dataTable is not null);

        var row = dataTable.NewRow();
        for (int i = 0; i < _model.ColumnValues.Count; i++)
        {
            var value = _model.ColumnValues[i];
            row[i] = value;
        }

        dataTable.Rows.Add(row);

        // Let's just not bother and reload the row with a separate query,
        // it's just so much simpler.
        await MoveToRow(dataTable.Rows.Count - 1);
    }

    private Task DoSaveCurrent()
    {
        var dataTable = _model.CurrentDataTable;
        Debug.Assert(dataTable is not null);
        dataTable.AcceptChanges();
        return Task.CompletedTask;
    }

    private void SelectTable(int tableIndex)
    {
        CurrentTableRowIndex = null;
        var table = _model.TableModels![tableIndex];
        int prevCount = _columns.Count;
        for (int i = _columns.Count - 1; i >= table.Columns.Count; i--)
        {
            _columns.RemoveAt(i);
        }
        CollectionsMarshal.SetCount(_model.ColumnValues, table.Columns.Count);
        for (int i = prevCount; i < table.Columns.Count; i++)
        {
            _model.ColumnValues[i] = "";
        }

        {
            int c = Math.Min(prevCount, _columns.Count);
            for (int i = 0; i < c; i++)
            {
                _columns[i].OnTableChanged();
            }
        }
        {
            for (int i = prevCount; i < table.Columns.Count; i++)
            {
                _columns.Add(new ColumnViewModel(_model, i));
            }
            _model.CurrentTableSchemaIndex = tableIndex;
            _model.TriggerAllValuesChanged();
        }
    }
}

public sealed partial class MainMenu : Window
{
    private MainMenuViewModel ViewModel => (MainMenuViewModel) DataContext;
    public MainMenu(MainMenuViewModel viewModel)
    {
        DataContext = viewModel;
        InitializeComponent();
    }

    private void TextBox_KeyEnterUpdate(object sender, KeyEventArgs eventArgs)
    {
        if (eventArgs.Key != Key.Enter)
            return;

        var textBox = (TextBox) sender;
        var property = TextBox.TextProperty;
        var binding = BindingOperations.GetBindingExpression(textBox, property);
        binding?.UpdateSource();
    }
}