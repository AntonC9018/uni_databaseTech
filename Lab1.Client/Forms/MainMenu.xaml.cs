using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Lab1.DataLayer;
using Microsoft.Data.SqlClient;

namespace Laborator1;

public sealed class MainMenuModel : ObservableObject
{
    public List<string> ColumnValues;
    public List<ColumnSchema> ColumnSchemas;
}

public sealed class TableSchemaViewModel
{
    public required string Name { get; init; }
    public required ColumnSchema[] Columns { get; init; }
    public IEnumerable<ColumnSchema> IdColumns => Columns.Where(c => c.IsId);
    public required string Schema { get; init; }
    public FullyQualifiedName FullyQualifiedName => new(Schema, Name);
}

public sealed partial class ColumnViewModel : ObservableObject
{
    public ColumnViewModel(MainMenuModel model, int index)
    {
        _model = model;
        _index = index;
    }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Name))]
    [NotifyPropertyChangedFor(nameof(Value))]
    [NotifyPropertyChangedFor(nameof(IsReadOnly))]
    private MainMenuModel _model;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Model))]
    private int _index;

    public ColumnSchema Schema => Model.ColumnSchemas[Index];
    public string Name => Schema.Name;

    public string Value
    {
        get => Model.ColumnValues[Index];
        set => Model.ColumnValues[Index] = value;
    }

    public bool IsReadOnly => Schema.IsAutoGenerated;
}

public sealed partial class MainMenuViewModel : ObservableObject
{
    public MainMenuViewModel(
        TableSchemaViewModel[] tableModels,
        SqlConnection connection,
        CancellationToken applicationCancellationToken,
        MainMenuModel model)
    {
        _tableModels = tableModels;
        _connection = connection;
        _applicationCancellationToken = applicationCancellationToken;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(applicationCancellationToken);
        _loadingCancellationToken = _cts.Token;
        _model = model;
    }

    private readonly MainMenuModel _model;


    private readonly TableSchemaViewModel[] _tableModels;
    private readonly ObservableCollection<ColumnViewModel> _columns = new();
    private readonly SqlConnection _connection;

    [ObservableProperty]
    private int? _currentTableSchemaIndex = null;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsTableSelected))]
    private int? _currentTableRowIndex = null;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    private bool _isFirstRow = true;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    private bool _isLastRow = true;

    public IEnumerable<TableSchemaViewModel> TableSchemas => _tableModels;

    [ObservableProperty]
    private bool _isLoading;

    private CancellationToken _applicationCancellationToken;
    private CancellationToken _loadingCancellationToken;
    private CancellationTokenSource _cts;
    private readonly SemaphoreSlim _loadingOperationLock = new(1, 1);

    public bool CanMovePreviousRow => !IsFirstRow && !IsLoading;
    public bool CanMoveNextRow => !IsFirstRow && !IsLoading;
    public bool IsTableSelected => CurrentTableSchemaIndex is not null;

    private int GetOffsetCurrentIndexWithFallback(int offset)
    {
        int? maybeCurrentRowIndex = CurrentTableRowIndex;
        int rowIndex;
        if (maybeCurrentRowIndex is null)
            rowIndex = 0;
        else
            rowIndex = maybeCurrentRowIndex.Value + offset;
        return rowIndex;
    }

    [RelayCommand]
    public void MovePreviousRow()
    {
        if (!CanMovePreviousRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
        MoveToRowFireAndForget(rowIndex);
    }

    [RelayCommand]
    public void MoveNextRow()
    {
        if (!CanMoveNextRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(1);
        MoveToRowFireAndForget(rowIndex);
    }

    private record struct ErrorMessage(string? Value)
    {
        public static implicit operator ErrorMessage(string? value) => new(value);
    }

    private async void DoOperationFireAndForget(Func<Task<ErrorMessage>> func)
    {
        try
        {
            await _loadingOperationLock.WaitAsync(_loadingCancellationToken);
        }
        catch (Exception)
        {
            return;
        }

        try
        {
            IsLoading = true;

            try
            {
                var errorMessage = await func();
                if (errorMessage.Value is not null)
                {
                    MessageBox.Show($"No such row {errorMessage.Value}");
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
            }

            IsLoading = false;
        }
        finally
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(_applicationCancellationToken);
            _loadingCancellationToken = _cts.Token;
            _loadingOperationLock.Release();
        }
    }


    private void MoveToRowFireAndForget(int rowIndex)
    {
        DoOperationFireAndForget(async () =>
        {
            bool rowFound = await MoveToRow(rowIndex);
            if (!rowFound)
                return rowIndex.ToString();
            return null;
        });
    }

    private TableSchemaViewModel GetCurrentTable()
    {
        int? maybeSchemaIndex = CurrentTableSchemaIndex;
        Debug.Assert(maybeSchemaIndex is not null);
        int schemaIndex = maybeSchemaIndex.Value;

        var table = _tableModels[schemaIndex];
        return table;
    }

    private struct Cursor
    {
        public bool FoundStart;
        public bool FoundEnd;
        public bool FoundElement;
    }

    private async Task<bool> MoveToRow(int rowIndex)
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildGetRowAtIndexQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForGetRowAtIndexQuery(rowIndex);
        command.Parameters.AddRange(parameters);

        var reader = await command.ExecuteReaderAsync(_loadingCancellationToken);
        Cursor cursor = new();        
        
        for (int iteration = 0; iteration < 3; iteration++)
        {
            bool moved = await reader.ReadAsync(_loadingCancellationToken);
            if (!moved)
                break;

            int rowNumber = reader.GetInt32(0);
            if (rowNumber < rowIndex)
            {
                Debug.Assert(!cursor.FoundStart);
                cursor.FoundStart = true;
            }
            else if (rowNumber > rowIndex)
            {
                Debug.Assert(!cursor.FoundEnd);
                cursor.FoundEnd = true;
            }
            else
            {
                Debug.Assert(!cursor.FoundElement);
                cursor.FoundElement = true;
            }

            var columnValues = _model.ColumnValues;
            var modelColumns = _columns;
            int propertiesOffset = 1;
            for (int i = modelColumns.Count - 1; i >= columnValues.Count; i--)
            {
                modelColumns.RemoveAt(i);
            }
            for (int i = modelColumns.Count; i < columnValues.Count; i++)
            {
                modelColumns.Add(new ColumnViewModel(_model, i));
            }
            CollectionsMarshal.SetCount(_model.ColumnValues, columnValues.Count);
            for (int i = 0; i < columnValues.Count; i++)
            {
                var value = reader.GetValue(i);
                _model.ColumnValues[i] = value?.ToString() ?? "";
            }
        }

        CurrentTableRowIndex = rowIndex;
        return true;
    }

    private async Task DeleteCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildDeleteRowWithKeyQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }

        var parameters = QueryBuilderHelper.GetParametersForDeleteRowWithKeyQuery(
            table,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        await command.ExecuteNonQueryAsync(_loadingCancellationToken);

        if (IsLastRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
            await MoveToRow(rowIndex);
        }
        else if (IsFirstRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(1);
            await MoveToRow(rowIndex);
        }
        else
        {
            // Table now empty
            CurrentTableRowIndex = null;
        }


        // get values of keys.
        // make query that does a WHERE and searches those keys.
        // get the count of rows remaining.
        // move to next / previous / no row.
        // update isFirst and isLast row.
    }

    private async Task InsertCurrent()
    {
        // get values of non-keys.
        // make query that does an INSERT INTO and returns the keys.
        // figure out which index it ends up at through a reverse query to ensure ordering.
        // reset the values of the model.
        // update isFirst and isLast.
    }

    private async Task SaveCurrent()
    {
        // get values of non-keys.
        // get values of keys.
        // make an UPDATE query that searches by keys, and sets non-keys.
    }
}

public sealed partial class MainMenu : Window
{

}