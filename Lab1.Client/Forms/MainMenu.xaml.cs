using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Lab1.DataLayer;
using Microsoft.Data.SqlClient;

namespace Laborator1;

public sealed partial class MainMenuModel : ObservableObject
{
    public MainMenuModel(TableSchemaModel[] tableModels) => TableModels = tableModels;

    public readonly TableSchemaModel[] TableModels;

    [ObservableProperty]
    private int? _currentTableSchemaIndex = null;

    public List<string> ColumnValues = new();

    public TableSchemaModel? CurrentTableModel
    {
        get
        {
            if (CurrentTableSchemaIndex is { } index)
                return TableModels[index];
            return null;
        }
    }

    public ColumnSchema[] ColumnSchemas
    {
        get
        {
            var table = CurrentTableModel;
            if (table is null)
                return Array.Empty<ColumnSchema>();
            return table.Columns;
        }
    }

    public void TriggerAllValuesChanged()
    {
        OnPropertyChanged(nameof(ColumnValues));
    }
}

public sealed class TableSchemaModel
{
    public required string Name { get; init; }
    public required ColumnSchema[] Columns { get; init; }
    public IEnumerable<ColumnSchema> IdColumns => Columns.Where(c => c.IsId);
    public required string Schema { get; init; }
    public FullyQualifiedName FullyQualifiedName => new(Schema, Name);
}

public sealed partial class ColumnViewModel : ObservableObject
{
    public ColumnViewModel(MainMenuModel model, int index)
    {
        _model = model;
        _index = index;
    }

    private readonly MainMenuModel _model;
    private readonly int _index;

    private ColumnSchema Schema => _model.ColumnSchemas[_index];
    public string Name => Schema.Name;

    public string Value
    {
        get => _model.ColumnValues[_index];
        set => _model.ColumnValues[_index] = value;
    }

    private bool IsReadOnly => Schema.IsAutoGenerated;

    internal void OnTableChanged()
    {
        OnPropertyChanged(nameof(IsReadOnly));
        OnPropertyChanged(nameof(Name));
    }

    internal void OnRowChanged()
    {
        OnPropertyChanged(nameof(Value));
    }
}

public sealed partial class MainMenuViewModel : ObservableObject
{
    public MainMenuViewModel(
        SqlConnection connection,
        CancellationToken applicationCancellationToken,
        MainMenuModel model)
    {
        _connection = connection;
        _applicationCancellationToken = applicationCancellationToken;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(applicationCancellationToken);
        _loadingCancellationToken = _cts.Token;
        _model = model;

        _model.PropertyChanged += (_, args) =>
        {
            switch (args.PropertyName)
            {
                case nameof(MainMenuModel.ColumnValues):
                {
                    foreach (var column in _columns)
                        column.OnRowChanged();
                    break;
                }
                case nameof(MainMenuModel.CurrentTableSchemaIndex):
                {
                    foreach (var column in _columns)
                        column.OnTableChanged();
                    break;
                }
            }
        };
    }

    private readonly MainMenuModel _model;
    private readonly ObservableCollection<ColumnViewModel> _columns = new();
    private readonly SqlConnection _connection;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsTableSelected))]
    private int? _currentTableRowIndex = null;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    private bool _isFirstRow = true;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    private bool _isLastRow = true;

    public IEnumerable<TableSchemaModel> TableSchemas => _model.TableModels;

    [ObservableProperty]
    private bool _isLoading;

    private readonly CancellationToken _applicationCancellationToken;
    private CancellationToken _loadingCancellationToken;
    private CancellationTokenSource _cts;
    private readonly SemaphoreSlim _loadingOperationLock = new(1, 1);

    public bool CanMovePreviousRow => !IsFirstRow && !IsLoading;
    public bool CanMoveNextRow => !IsFirstRow && !IsLoading;
    public bool IsTableSelected => _model.CurrentTableSchemaIndex is not null;

    private int GetOffsetCurrentIndexWithFallback(int offset)
    {
        int? maybeCurrentRowIndex = CurrentTableRowIndex;
        int rowIndex;
        if (maybeCurrentRowIndex is null)
            rowIndex = 0;
        else
            rowIndex = maybeCurrentRowIndex.Value + offset;
        return rowIndex;
    }

    [RelayCommand]
    public void MovePreviousRow()
    {
        if (!CanMovePreviousRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
        MoveToRowFireAndForget(rowIndex);
    }

    [RelayCommand]
    public void MoveNextRow()
    {
        if (!CanMoveNextRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(1);
        MoveToRowFireAndForget(rowIndex);
    }

    private record struct ErrorMessage(string? Value)
    {
        public static implicit operator ErrorMessage(string? value) => new(value);
    }

    private async void DoOperationFireAndForget(Func<Task<ErrorMessage>> func)
    {
        if (IsLoading)
            return;

        try
        {
            await _loadingOperationLock.WaitAsync(_loadingCancellationToken);
        }
        catch (Exception)
        {
            return;
        }

        try
        {
            if (IsLoading)
                return;

            IsLoading = true;

            try
            {
                var errorMessage = await func();
                if (errorMessage.Value is not null)
                {
                    MessageBox.Show(errorMessage.Value);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
            }

            IsLoading = false;
        }
        finally
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(_applicationCancellationToken);
            _loadingCancellationToken = _cts.Token;
            _loadingOperationLock.Release();
        }
    }

    private void MoveToRowFireAndForget(int rowIndex)
    {
        DoOperationFireAndForget(async () =>
        {
            bool rowFound = await MoveToRow(rowIndex);
            if (!rowFound)
                return $"Failed to move to row {rowIndex}.";
            return null;
        });
    }

    private void DeleteCurrentFireAndForget()
    {
        DoOperationFireAndForget(async () =>
        {
            await DeleteCurrent();
            return null;
        });
    }

    private void InsertCurrentFireAndForget()
    {
        DoOperationFireAndForget(async () =>
        {
            await InsertCurrent();
            return null;
        });
    }

    private void SaveCurrentFireAndForget()
    {
        DoOperationFireAndForget(async () =>
        {
            await SaveCurrent();
            return null;
        });
    }

    private TableSchemaModel GetCurrentTable()
    {
        int? maybeSchemaIndex = _model.CurrentTableSchemaIndex;
        Debug.Assert(maybeSchemaIndex is not null);
        int schemaIndex = maybeSchemaIndex.Value;

        var table = _model.TableModels[schemaIndex];
        return table;
    }

    private struct Cursor
    {
        public bool FoundStart;
        public bool FoundEnd;
        public bool FoundElement;
    }

    private async Task<bool> MoveToRow(int rowIndex)
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildGetRowAtIndexQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForGetRowAtIndexQuery(rowIndex);
        command.Parameters.AddRange(parameters);

        var reader = await command.ExecuteReaderAsync(_loadingCancellationToken);
        Cursor cursor = new();        
        
        for (int iteration = 0; iteration < 3; iteration++)
        {
            bool moved = await reader.ReadAsync(_loadingCancellationToken);
            if (!moved)
                break;

            int rowNumber = reader.GetInt32(0);
            if (rowNumber < rowIndex)
            {
                Debug.Assert(!cursor.FoundStart);
                cursor.FoundStart = true;
            }
            else if (rowNumber > rowIndex)
            {
                Debug.Assert(!cursor.FoundEnd);
                cursor.FoundEnd = true;
            }
            else
            {
                Debug.Assert(!cursor.FoundElement);
                cursor.FoundElement = true;
            }

            if (rowNumber != rowIndex)
                continue;

            var columnValues = _model.ColumnValues;
            int propertiesOffset = 1;

            // var modelColumns = _columns;
            // for (int i = modelColumns.Count - 1; i >= columnValues.Count; i--)
            // {
            //     modelColumns.RemoveAt(i);
            // }
            // for (int i = modelColumns.Count; i < columnValues.Count; i++)
            // {
            //     modelColumns.Add(new ColumnViewModel(_model, i));
            // }
            // CollectionsMarshal.SetCount(_model.ColumnValues, columnValues.Count);

            for (int i = 0; i < columnValues.Count; i++)
            {
                var value = reader.GetValue(i);
                _model.ColumnValues[i] = value.ToString() ?? "";
            }
        }

        Reset();
        void Reset()
        {
            IsLastRow = !cursor.FoundEnd;
            IsFirstRow = !cursor.FoundStart;

            if (cursor.FoundElement)
            {
                CurrentTableRowIndex = rowIndex;
                return;
            }

            // foreach (ref var column in CollectionsMarshal.AsSpan(_model.ColumnValues))
            //     column = "";

            CurrentTableRowIndex = null;
        }

        _model.TriggerAllValuesChanged();
        return true;
    }

    private async Task DeleteCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildDeleteRowWithKeyQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }

        var parameters = QueryBuilderHelper.GetParametersForDeleteRowWithKeyQuery(
            table,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        await command.ExecuteNonQueryAsync(_loadingCancellationToken);

        if (IsLastRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
            await MoveToRow(rowIndex);
        }
        else if (IsFirstRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(1);
            await MoveToRow(rowIndex);
        }
        else
        {
            // Table now empty
            CurrentTableRowIndex = null;
        }
    }

    private async Task InsertCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildInsertRowWithValuesQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForInsertRowWithValuesQuery(
            table,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        int rowIndex = (int) await command.ExecuteScalarAsync(_loadingCancellationToken);

        // Let's just not bother and reload the row with a separate query,
        // it's just so much simpler.
        await MoveToRow(rowIndex);
    }

    private async Task SaveCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildUpdateRowQuery(stringBuilder, table);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForUpdateRowQuery(
            table,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        await command.ExecuteNonQueryAsync(_loadingCancellationToken);
    }

    private void SelectTable(int tableIndex)
    {
        CurrentTableRowIndex = null;
        var table = _model.TableModels[tableIndex];
        int prevCount = _columns.Count;
        for (int i = _columns.Count - 1; i >= table.Columns.Length; i--)
        {
            _columns.RemoveAt(i);
        }
        CollectionsMarshal.SetCount(_model.ColumnValues, table.Columns.Length);
        for (int i = prevCount; i < table.Columns.Length; i++)
        {
            _model.ColumnValues[i] = "";
        }
        for (int i = prevCount; i < table.Columns.Length; i++)
        {
            _columns.Add(new ColumnViewModel(_model, i));
        }
        _model.ColumnValues = new List<string>();
        _model.CurrentTableSchemaIndex = tableIndex;
        _model.TriggerAllValuesChanged();
    }
}

public sealed partial class MainMenu : Window
{

}