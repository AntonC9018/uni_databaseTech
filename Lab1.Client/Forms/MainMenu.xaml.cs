using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Documents;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Lab1.DataLayer;
using Microsoft.Data.SqlClient;

namespace Laborator1;

public sealed partial class MainMenuModel : ObservableObject
{
    public TableModel[]? TableModels;

    [ObservableProperty]
    private int? _currentTableSchemaIndex = null;

    public List<string> ColumnValues = new();

    public TableModel? CurrentTableModel
    {
        get
        {
            if (TableModels is null)
                return null;
            if (CurrentTableSchemaIndex is { } index)
                return TableModels[index];
            return null;
        }
    }

    public IList<ColumnSchema> ColumnSchemas
    {
        get
        {
            var table = CurrentTableModel;
            if (table is null)
                return Array.Empty<ColumnSchema>();
            return table.Columns;
        }
    }

    public void TriggerAllValuesChanged()
    {
        OnPropertyChanged(nameof(ColumnValues));
    }
}

public sealed class TableSchemaModel
{
    public TableSchemaModel(TableModel model) => Model = model;

    public TableModel Model { get; }

    public string Name => Model.Name.Name;
    public string Schema => Model.Name.Schema;
    public List<ColumnSchema> Columns => Model.Columns;
    public IEnumerable<ColumnSchema> IdColumns => Columns.Where(c => c.IsId);
    public FullyQualifiedName FullyQualifiedName => new(Schema, Name);
    public override string ToString() => FullyQualifiedName.ToString();
}

public sealed partial class ColumnViewModel : ObservableObject
{
    public ColumnViewModel(MainMenuModel model, int index)
    {
        _model = model;
        _index = index;
    }

    private readonly MainMenuModel _model;
    private readonly int _index;

    private ColumnSchema Schema => _model.ColumnSchemas[_index];
    public string Name => Schema.Name;

    public string Value
    {
        get => _model.ColumnValues[_index];
        set => _model.ColumnValues[_index] = value;
    }

    public bool IsReadOnly => Schema.IsAutoGenerated;
    public bool IsEditable => !Schema.IsAutoGenerated;

    internal void OnTableChanged()
    {
        OnPropertyChanged(nameof(IsReadOnly));
        OnPropertyChanged(nameof(Name));
    }

    internal void OnRowChanged()
    {
        OnPropertyChanged(nameof(Value));
    }
}

public sealed partial class MainMenuViewModel : ObservableObject
{
    public MainMenuViewModel(
        SqlConnection connection,
        CancellationToken applicationCancellationToken,
        MainMenuModel model)
    {
        _connection = connection;
        _applicationCancellationToken = applicationCancellationToken;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(applicationCancellationToken);
        _loadingCancellationToken = _cts.Token;
        _model = model;

        _model.PropertyChanged += (_, args) =>
        {
            switch (args.PropertyName)
            {
                case nameof(MainMenuModel.ColumnValues):
                {
                    foreach (var column in _columns)
                        column.OnRowChanged();
                    break;
                }
                case nameof(MainMenuModel.CurrentTableSchemaIndex):
                {
                    CurrentTableSchemaIndex = _model.CurrentTableSchemaIndex;
                    break;
                }
            }
        };

        LoadTablesFireAndForget();
    }

    private readonly MainMenuModel _model;
    private readonly ObservableCollection<ColumnViewModel> _columns = new();
    private readonly SqlConnection _connection;
    private TableSchemaModel[] _tables = Array.Empty<TableSchemaModel>();

    public int? CurrentTableSchemaIndex
    {
        get => _model.CurrentTableSchemaIndex;
        set
        {
            if (_model.CurrentTableSchemaIndex == value)
                return;

            if (value is { } v)
                SelectTable(v);

            else
                _model.CurrentTableSchemaIndex = null;
        }
    }

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsTableSelected))]
    private int? _currentTableRowIndex = null;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    [NotifyPropertyChangedFor(nameof(IsNotFirstRow))]
    private bool _isFirstRow = true;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    [NotifyPropertyChangedFor(nameof(IsNotLastRow))]
    private bool _isLastRow = true;

    public IEnumerable<TableSchemaModel> TableSchemas => _tables;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMovePreviousRow))]
    [NotifyPropertyChangedFor(nameof(CanMoveNextRow))]
    private bool _isLoading;

    private readonly CancellationToken _applicationCancellationToken;
    private CancellationToken _loadingCancellationToken;
    private CancellationTokenSource _cts;
    private readonly SemaphoreSlim _loadingOperationLock = new(1, 1);

    public bool CanMovePreviousRow => !IsFirstRow && !IsLoading;
    public bool CanMoveNextRow => !IsFirstRow && !IsLoading;
    public bool IsTableSelected => _model.CurrentTableSchemaIndex is not null;
    public bool IsNotFirstRow => !IsFirstRow;
    public bool IsNotLastRow => !IsLastRow;
    public bool IsRowSelected => CurrentTableRowIndex is not null;

    public ObservableCollection<ColumnViewModel> Columns => _columns;

    private int GetOffsetCurrentIndexWithFallback(int offset)
    {
        int? maybeCurrentRowIndex = CurrentTableRowIndex;
        int rowIndex;
        if (maybeCurrentRowIndex is null)
            rowIndex = 0;
        else
            rowIndex = maybeCurrentRowIndex.Value + offset;
        return rowIndex;
    }

    private void LoadTablesFireAndForget()
    {
        DoOperationFireAndForget(async () =>
        {
            await _connection.OpenAsync(_loadingCancellationToken);
            if (_connection.State != ConnectionState.Open)
                return "Failed to open connection.";

            var tables = await DatabaseSchemaHelper.GetTables(_connection, _loadingCancellationToken);
            _tables = tables.Select(t => new TableSchemaModel(t)).ToArray();
            _model.TableModels = tables;
            if (_tables.Length > 0)
                SelectTable(0);
            OnPropertyChanged(nameof(TableSchemas));
            return null;
        });
    }

    [RelayCommand]
    public void MovePreviousRow()
    {
        if (!CanMovePreviousRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
        MoveToRowFireAndForget(rowIndex);
    }

    [RelayCommand]
    public void MoveNextRow()
    {
        if (!CanMoveNextRow)
            return;

        int rowIndex = GetOffsetCurrentIndexWithFallback(1);
        MoveToRowFireAndForget(rowIndex);
    }

    private record struct ErrorMessage(string? Value)
    {
        public static implicit operator ErrorMessage(string? value)
        {
            if (value is not null)
                throw new InvalidOperationException(value);
            return new(value);
        }
    }

    private async void DoOperationFireAndForget(Func<Task<ErrorMessage>> func)
    {
        await DoOperationFireAndForget1(func);
    }

    private async Task DoOperationFireAndForget1(Func<Task<ErrorMessage>> func)
    {
        if (IsLoading)
            return;

        try
        {
            await _loadingOperationLock.WaitAsync(_loadingCancellationToken);
        }
        catch (Exception)
        {
            return;
        }

        try
        {
            if (IsLoading)
                return;

            IsLoading = true;

            try
            {
                var errorMessage = await func();
                if (errorMessage.Value is not null)
                {
                    MessageBox.Show(errorMessage.Value);
                }
            }
            catch (Exception e)
            {
                StringBuilder sb = new();

                Append(e);
                // ReSharper disable once VariableHidesOuterVariable
                void Append(Exception e)
                {
                    sb.AppendLine(e.Message);
                    sb.AppendLine(e.StackTrace);
                    if (e.InnerException is { } inner)
                    {
                        Append(inner);
                    }
                    if (e is AggregateException aggregateException)
                    {
                        foreach (var innerException in aggregateException.InnerExceptions)
                        {
                            Append(innerException);
                        }
                    }
                }

                // Aggregate exception
                MessageBox.Show(sb.ToString(), "Error");
            }

            IsLoading = false;
        }
        finally
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(_applicationCancellationToken);
            _loadingCancellationToken = _cts.Token;
            _loadingOperationLock.Release();
        }
    }

    private void MoveToRowFireAndForget(int rowIndex)
    {
        DoOperationFireAndForget(async () =>
        {
            bool rowFound = await MoveToRow(rowIndex);
            if (!rowFound)
                return $"Failed to move to row {rowIndex}.";
            return null;
        });
    }

    [RelayCommand]
    public void DeleteCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoDeleteCurrent();
            return null;
        });
    }

    [RelayCommand]
    public void InsertCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoInsertCurrent();
            return null;
        });
    }

    [RelayCommand]
    public void SaveCurrent()
    {
        DoOperationFireAndForget(async () =>
        {
            await DoSaveCurrent();
            return null;
        });
    }

    private TableSchemaModel GetCurrentTable()
    {
        int? maybeSchemaIndex = _model.CurrentTableSchemaIndex;
        Debug.Assert(maybeSchemaIndex is not null);
        int schemaIndex = maybeSchemaIndex.Value;

        var table = _tables[schemaIndex];
        return table;
    }

    private struct Cursor
    {
        public bool FoundStart;
        public bool FoundEnd;
        public bool FoundElement;
    }

    private async Task<bool> MoveToRow(int rowIndex)
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildGetRowAtIndexQuery(stringBuilder, table.Model);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForGetRowAtIndexQuery(rowIndex);
        command.Parameters.AddRange(parameters);

        var reader = await command.ExecuteReaderAsync(_loadingCancellationToken);
        Cursor cursor = new();        
        
        for (int iteration = 0; iteration < 3; iteration++)
        {
            bool moved = await reader.ReadAsync(_loadingCancellationToken);
            if (!moved)
                break;

            int rowNumber = reader.GetInt32(0);
            if (rowNumber < rowIndex)
            {
                Debug.Assert(!cursor.FoundStart);
                cursor.FoundStart = true;
            }
            else if (rowNumber > rowIndex)
            {
                Debug.Assert(!cursor.FoundEnd);
                cursor.FoundEnd = true;
            }
            else
            {
                Debug.Assert(!cursor.FoundElement);
                cursor.FoundElement = true;
            }

            if (rowNumber != rowIndex)
                continue;

            var columnValues = _model.ColumnValues;

            for (int i = 0; i < columnValues.Count; i++)
            {
                var value = reader.GetValue(i);
                _model.ColumnValues[i] = value.ToString() ?? "";
            }
        }

        void Reset()
        {
            IsLastRow = !cursor.FoundEnd;
            IsFirstRow = !cursor.FoundStart;

            if (cursor.FoundElement)
            {
                CurrentTableRowIndex = rowIndex;
                return;
            }

            // foreach (ref var column in CollectionsMarshal.AsSpan(_model.ColumnValues))
            //     column = "";

            CurrentTableRowIndex = null;
        }

        {
            Reset();
            _model.TriggerAllValuesChanged();
        }
        return true;
    }

    private async Task DoDeleteCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildDeleteRowWithKeyQuery(stringBuilder, table.Model);
            command.CommandText = stringBuilder.ToString();
        }

        var parameters = QueryBuilderHelper.GetParametersForDeleteRowWithKeyQuery(
            table.Model,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        await command.ExecuteNonQueryAsync(_loadingCancellationToken);

        if (IsLastRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(-1);
            await MoveToRow(rowIndex);
        }
        else if (IsFirstRow)
        {
            int rowIndex = GetOffsetCurrentIndexWithFallback(1);
            await MoveToRow(rowIndex);
        }
        else
        {
            CurrentTableRowIndex = null;
        }
    }

    private async Task DoInsertCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildInsertRowWithValuesQuery(stringBuilder, table.Model);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForInsertRowWithValuesQuery(
            table.Model,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        int rowIndex = (int) await command.ExecuteScalarAsync(_loadingCancellationToken);

        // Let's just not bother and reload the row with a separate query,
        // it's just so much simpler.
        await MoveToRow(rowIndex);
    }

    private async Task DoSaveCurrent()
    {
        var table = GetCurrentTable();
        var command = _connection.CreateCommand();
        {
            var stringBuilder = new StringBuilder();
            QueryBuilderHelper.BuildUpdateRowQuery(stringBuilder, table.Model);
            command.CommandText = stringBuilder.ToString();
        }
        var parameters = QueryBuilderHelper.GetParametersForUpdateRowQuery(
            table.Model,
            _model.ColumnValues);
        command.Parameters.AddRange(parameters);

        await command.ExecuteNonQueryAsync(_loadingCancellationToken);
    }

    private void SelectTable(int tableIndex)
    {
        CurrentTableRowIndex = null;
        var table = _model.TableModels![tableIndex];
        int prevCount = _columns.Count;
        for (int i = _columns.Count - 1; i >= table.Columns.Count; i--)
        {
            _columns.RemoveAt(i);
        }
        CollectionsMarshal.SetCount(_model.ColumnValues, table.Columns.Count);
        for (int i = prevCount; i < table.Columns.Count; i++)
        {
            _model.ColumnValues[i] = "";
        }

        // Application.Current.Dispatcher.InvokeAsync(() =>
        {
            int c = Math.Min(prevCount, _columns.Count);
            for (int i = 0; i < c; i++)
            {
                _columns[i].OnTableChanged();
            }
        }
        {
            for (int i = prevCount; i < table.Columns.Count; i++)
            {
                _columns.Add(new ColumnViewModel(_model, i));
            }
            _model.CurrentTableSchemaIndex = tableIndex;
            _model.TriggerAllValuesChanged();
        }
        // );
    }
}

public sealed partial class MainMenu : Window
{
    private MainMenuViewModel ViewModel => (MainMenuViewModel) DataContext;
    public MainMenu(MainMenuViewModel viewModel)
    {
        DataContext = viewModel;
        InitializeComponent();
    }
}