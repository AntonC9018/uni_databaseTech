using System;
using System.Linq;
using System.Text;
using Laborator1;

namespace Lab1.DataLayer;

public static class QueryBuilderHelper
{
    public const string CurrentIndexParameterName = "currentIndex";
    public const string ValueVariablePrefix = "v";

    public static void GetRowAtIndexQuery(
        StringBuilder sb,
        TableSchemaViewModel tableSchema)
    {
        var propertiesList = tableSchema.Columns
            .Select(c => c.Name)
            .JoinableDbPropertyList();
        var idPropertiesList = tableSchema.IdColumns
            .Select(c => c.Name)
            .JoinableDbPropertyList();

        using var t1Props = propertiesList.Prefix("t1");
        using var tProps = idPropertiesList.Prefix("t");
        using var t2Props = idPropertiesList.Prefix("t2");

        sb.Append($"""
        SELECT TOP(1) FROM
        (
            SELECT {t1Props} FROM
            (
                SELECT
                    t.*,
                    ROW_NUMBER() OVER (
                        PARTITION BY {tProps}) AS rowNumberX
                FROM {tableSchema.FullyQualifiedName} AS t
            ) AS t1
            WHERE t1.rowNumberX <= @{CurrentIndexParameterName}
        ) AS t2
        ORDER BY {t2Props}
        """);
    }

    public readonly struct VariableName : ISpanFormattable
    {
        private readonly int _index;
        public VariableName(int index) => _index = index;

        public string ToString(
            string? format,
            IFormatProvider? formatProvider)
        {
            throw new NotImplementedException();
        }

        public bool TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider)
        {
            return destination.TryWrite(
                provider,
                $"@{ValueVariablePrefix}{_index}",
                out charsWritten);
        }
    }

    public static void GetDeleteRowWithKeyQuery(
        StringBuilder sb,
        TableSchemaViewModel tableSchema)
    {
        var equalValueList = tableSchema.IdColumns
            .Select(x => new FullyQualifiedName("t", x.Name))
            .EqualValueList(i => new VariableName(i), delimiter: " AND ");
        sb.Append($"""
        DELETE FROM {tableSchema.FullyQualifiedName} AS t
        WHERE {equalValueList}
        """);
    }

    public static void GetInsertRowWithValuesQuery(
        StringBuilder sb,
        TableSchemaViewModel tableSchema)
    {
        var notAutogeneratedColumns = tableSchema.Columns.Where(c => !c.IsAutoGenerated);
        var propertiesList = notAutogeneratedColumns.Select(c => c.Name)
            .JoinableDbPropertyList()
            .Prefix(null);
        var valuesList = notAutogeneratedColumns
            .Select((_, i) => new VariableName(i))
            .JoinableDbPropertyList()
            .Prefix(null);

        sb.Append($"""
        INSERT INTO {tableSchema.FullyQualifiedName} AS t
        (
            {notAutogeneratedColumns}
        )
        VALUES
        (
            {valuesList}
        )
        """);
    }

    public static void GetUpdateRowQuery(
        StringBuilder sb,
        TableSchemaViewModel tableSchema)
    {
        var notIdColumns = tableSchema.Columns.Where(c => !c.IsId);
        int nonIdColumnCount = notIdColumns.Count();
        var notIdColumnAssignments = notIdColumns
            .Select(c => new FullyQualifiedName("t", c.Name))
            .EqualValueList(i => new VariableName(i), delimiter: ", ");
        var keyColumnChecks = tableSchema.Columns.Where(c => c.IsId)
            .Select(x => new FullyQualifiedName("t", x.Name))
            .EqualValueList(i => new VariableName(i + nonIdColumnCount), delimiter: " AND ");

        sb.Append($"""
        UPDATE {tableSchema.FullyQualifiedName} AS t
        SET {notIdColumnAssignments}
        WHERE {keyColumnChecks}
        """);
    }
}